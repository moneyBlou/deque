#include <iostream>

using namespace std;

class Deque {
private:
    int* arr;        // Указатель на динамически выделенный массив
    int front;       // Индекс первого элемента дека
    int back;        // Индекс последнего элемента дека
    int size;        // Текущий размер дека
    int capacity;    // Максимальная вместимость дека

public:
    // Конструктор: инициализирует дек с заданной вместимостью
    Deque(int capacity) {
        this->capacity = capacity;   // Устанавливаем вместимость дека
        arr = new int[capacity];  // Выделяем память под массив целых чисел
        front = -1;             // Изначально дек пуст: front не указывает ни на какой элемент
        back = -1;              // И back тоже
        size = 0;               // Размер дека равен 0
    }

    // Деструктор: освобождает выделенную память
    ~Deque() {
        delete[] arr;  // Освобождаем память, выделенную под массив
    }

    // Проверка, пуст ли дек
    bool isEmpty() {
        return size == 0;  // Дек пуст, если его размер равен 0
    }

    // Проверка, полон ли дек
    bool isFull() {
        return size == capacity;  // Дек полон, если его размер равен его вместимости
    }

    // Получение текущего размера дека
    int getSize() {
        return size;   // Возвращаем текущий размер дека
    }

    // Получение максимальной вместимости дека
    int getCapacity() {
        return capacity;  // Возвращаем максимальную вместимость дека
    }

    // Изменение размера массива дека (увеличение вдвое)
    void resize() {
        int newCapacity = capacity * 2;  // Вычисляем новую вместимость, удваивая текущую
        int* newArr = new int[newCapacity];  // Выделяем память под новый массив

        int j = 0;  // Инициализируем индекс для нового массива
        for (int i = front; j < size; j++, i = (i + 1) % capacity) {
            newArr[j] = arr[i];  // Копируем элементы из старого массива в новый
        }

        delete[] arr;  // Освобождаем память, выделенную под старый массив
        arr = newArr;   // Указываем указатель на новый массив
        front = 0;   // Сбрасываем front: теперь первый элемент в начале массива
        back = size - 1;  // Обновляем back: теперь последний элемент находится по индексу size - 1
        capacity = newCapacity;  // Обновляем вместимость

        cout << "Размер дека увеличен: " << capacity << endl;  // Сообщаем об увеличении размера
    }

    // Добавление элемента в начало дека
    void push_front(int element) {
        // Если дек полон, увеличиваем его размер
        if (size == capacity) {
            resize();
        }

        // Если дек пуст, то первый элемент будет и front, и back
        if (isEmpty()) {
            front = 0;
            back = 0;
        }
        else {
            // Иначе сдвигаем front влево (циклически)
            front = (front - 1 + capacity) % capacity;
        }

        arr[front] = element;  // Добавляем элемент в начало
        size++;   // Увеличиваем размер дека
    }

    // Добавление элемента в конец дека
    void push_back(int element) {
        // Если дек полон, увеличиваем его размер
        if (size == capacity) {
            resize();
        }

        // Если дек пуст, то первый элемент будет и front, и back
        if (isEmpty()) {
            front = 0;
            back = 0;
        }
        else {
            // Иначе сдвигаем back вправо (циклически)
            back = (back + 1) % capacity;
        }
        arr[back] = element;  // Добавляем элемент в конец
        size++;   // Увеличиваем размер дека
    }

    // Удаление элемента из начала дека
    int pop_front() {
        // Если дек пуст, сообщаем об ошибке и возвращаем -1
        if (isEmpty()) {
            cout << "Ошибка! Дек пуст!" << endl;
            return -1;
        }

        int element = arr[front];  // Запоминаем удаляемый элемент
        size--;   // Уменьшаем размер дека

        // Если после удаления дек стал пуст, сбрасываем front и back
        if (isEmpty()) {
            front = -1;
            back = -1;
        }
        else {
            // Иначе сдвигаем front вправо (циклически)
            front = (front + 1) % capacity;
        }

        return element;  // Возвращаем удаленный элемент
    }

    // Удаление элемента из конца дека
    int pop_back() {
        // Если дек пуст, сообщаем об ошибке и возвращаем -1
        if (isEmpty()) {
            cout << "Ошибка! Дек пуст!" << endl;
            return -1;
        }

        int element = arr[back];  // Запоминаем удаляемый элемент
        size--;   // Уменьшаем размер дека

        // Если после удаления дек стал пуст, сбрасываем front и back
        if (isEmpty()) {
            front = -1;
            back = -1;
        }
        else {
            // Иначе сдвигаем back влево (циклически)
            back = (back - 1 + capacity) % capacity;
        }
        return element;  // Возвращаем удаленный элемент
    }

    // Получение элемента из начала дека (без удаления)
    int get_front() {
        // Если дек пуст, сообщаем об ошибке и возвращаем -1
        if (isEmpty()) {
            cout << "Ошибка! Дек пуст!" << endl;
            return -1;
        }
        return arr[front];  // Возвращаем элемент, находящийся в начале дека
    }

    // Получение элемента из конца дека (без удаления)
    int get_back() {
        // Если дек пуст, сообщаем об ошибке и возвращаем -1
        if (isEmpty()) {
            cout << "Ошибка! Дек пуст!" << endl;
            return -1;
        }
        return arr[back];  // Возвращаем элемент, находящийся в конце дека
    }

    // Получение элемента по индексу
    int get_element_at(int index) {
        // Если дек пуст, индекс некорректен, сообщаем об ошибке и возвращаем -1
        if (isEmpty() || index < 0 || index >= size) {
            cout << "Ошибка! Дек пуст или индекс за пределами!" << endl;
            return -1;
        }
        return arr[(front + index) % capacity];  // Возвращаем элемент по указанному индексу
    }

    // Вывод содержимого дека в консоль
    void printDeque() {
        // Если дек пуст, выводим сообщение
        if (isEmpty()) {
            cout << "Ошибка! Дек пуст!" << endl;
            return;
        }

        cout << "Элементы дека: ";  // Выводим заголовок

        int i = front;  // Начинаем с front
        for (int j = 0; j < size; ++j) {
            cout << arr[i] << " ";   // Выводим текущий элемент
            i = (i + 1) % capacity;  // Переходим к следующему элементу (циклически)
        }

        cout << endl;  // Переводим строку
    }
};

int main() {
    // Создаем дек с начальной вместимостью 3
    Deque dq(3);

    // Добавляем элементы
    dq.push_front(1);  // Добавляем 1 в начало: дек = [1]
    dq.push_back(2);   // Добавляем 2 в конец: дек = [1, 2]
    dq.push_front(0);  // Добавляем 0 в начало: дек = [0, 1, 2]
    dq.printDeque();  // Выводим содержимое: Элементы дека: 0 1 2

    // Добавляем элемент, который превышает вместимость, вызывая resize
    dq.push_back(3);  // Добавляем 3 в конец: дек = [0, 1, 2, 3] (resize происходит здесь)
    dq.printDeque();  // Выводим содержимое: Элементы дека: 0 1 2 3

    // Получаем и выводим первый и последний элементы
    cout << "Front: " << dq.get_front() << endl;  // Выводим: Front: 0
    cout << "Back: " << dq.get_back() << endl;    // Выводим: Back: 3

    // Удаляем элементы
    dq.pop_front();   // Удаляем элемент из начала: дек = [1, 2, 3]
    dq.printDeque();  // Выводим содержимое: Элементы дека: 1 2 3

    dq.pop_back();    // Удаляем элемент из конца: дек = [1, 2]
    dq.printDeque();  // Выводим содержимое: Элементы дека: 1 2

    return 0;
}